import collections
from typing import Any, Dict, Iterator, Optional, Type, List, Union, Generic, TypeVar, Iterable


_KT = TypeVar('_KT')
_VT = TypeVar('_VT')

class OrderedMultiDict(dict[_KT, _VT]):
    root: List
    def add(self, k: _KT, v: _VT) -> None: ...
    def addlist(self, k: _KT, v: Iterable[...]) -> List[...]: ...
    def get(self, k: _KT, default: Optional [_VT] = None) -> _VT: ...
    def getlist(self, k: _KT, default: Optional [_VT] = None) -> _VT: ...
    def setdefault(self, k: _KT, default: Optional [_VT] = None) -> _VT: ...
    @classmethod
    def fromkeys(cls, keys: _KT, default: Optional [_VT] = None)-> List: ...
    def update(self, E:Dict[_KT, _VT] | Iterable[...], **F:Any) -> List: ... # не уверена вообще в этой типизации
    def update_extend(self, E:Dict[_KT, _VT | Iterable[...]] ) -> List: ... # не уверена вообще в этой типизации
    def pop(self, k: _KT, default: Optional [_VT] = None) -> _VT: ...
    def popall(self, k: _KT, default: Optional [_VT] = None) -> _VT: ...
    def poplast(self, k: _KT, default: Optional [_VT] = None) -> _VT: ...
    def iteritems(self, multi:bool = ...)-> OrderedMultiDict[_KT,_VT]: ...
    def iterkeys(self, multi:bool = ...)-> OrderedMultiDict[_KT]: ...
    def itervalues(self, multi: bool = ...) -> OrderedMultiDict[_VT]: ...
    # или def itervalues(self, multi:bool = ...)-> collections.Iterable[_VT]: ... тоже самое по iteritems и iterkeys
    def todict(self, multi:bool = ...)-> Dict[_KT,_VT]: ...
    def sorted(self, key:Union[None,_KT], reverse: bool) -> OrderedMultiDict[_KT,_VT]: ...
    def sortedvalues(self, key:Union[None,_KT], reverse: bool) -> OrderedMultiDict[_KT,_VT]: ...
    def keys(self, multi:bool = ...)-> List[_KT]: ...
    def values(self, multi:bool = ...)-> List[_VT]: ...
    def items(self, multi:bool = ...)-> List[_KT,_VT]: ...

class FastIterOrderedMultiDict(OrderedMultiDict[_KT, _VT]):
    def iteritems(self, multi:bool = ...)-> OrderedMultiDict[_KT,_VT]: ...
    def iterkeys(self, multi:bool = ...)-> OrderedMultiDict[_KT]: ...

class OneToOne(dict[_KT, _VT]):
    def pop(self, key:_KT, default: Optional [_VT] = None) -> _KT: ...
    def setdefault(self, key:_KT, default: Optional [_VT] = None) -> _KT: ...
    def update(self, dict_or_iterable:Dict[_KT,_VT] | Iterable[...], **kw)-> Dict[_KT,_VT]: ...

# как работать с object?
# class ManyToMany(object):

class FrozenDict(dict[_KT, _VT]):
    def updated(self, *a:_KT, **kw:_VT)-> FrozenDict[_KT, _VT]: ...
    @classmethod
    def fromkeys(cls, keys:_KT, value: Optional [_VT] = None)-> List: ...










